desc "Generate Structs from mysql tables"

def convert_define(type)
    case type.to_s
    when 'integer'
        'int'
    when 'boolean'
        'bool'
    else
        type.to_s
    end
end

def type_formatter(type)
  type = convert_define(type)
  case type
  when 'int'
    '%d'
  when 'float'
    '%d'
  when 'bool'
    '%t'
  when 'string'
    "'%s'"
  else
    raise "invalid type: #{type}"
  end
end

task :generate_tables => :environment do
  header = %Q{
/*
 * Generated by generate_tables
 * Warning: don't modify this file
 */
}
  structs_content = "#{header}package consts\n"
  struct_to_table_name = ""
  register_content = ""
  data_loader = []
  models = {}

  ActiveRecord::Base.connection.tables.each do |table_name|
    next if table_name == 'schema_migrations'
    next if table_name == 'schema_persistances'
    next if table_name == 'ar_internal_metadata'
    struct_name = table_name.singularize.camelize
    structs_content << "type #{struct_name} struct{\n"
    field_names = []
    field_types = []
    field_values = []
    field_formatters = []
    ActiveRecord::Base.connection.columns(table_name).each do |c| 
      if c.name != "uuid"
        field_names << c.name
        field_type = type_formatter(c.type)
        field_types << field_type
        field_values << "data.#{c.name.camelize}"
        field_formatters << "#{c.name}=#{field_type}"
      end
      structs_content << %Q{    #{c.name.camelize} #{convert_define(c.type)} `db:"#{c.name}"`\n}
    end
    structs_content << "}\n"
    struct_to_table_name << %Q{"#{struct_name}": "#{table_name}",\n}
    register_content << %Q{    dbInstance.AddTableWithName(#{struct_name}{}, "#{table_name}").SetKeys(false, "uuid")\n}
    data_loader << %Q{
  memstore.RegisterDataLoader("#{table_name}", func(playerId string, ets *memstore.MemStore) {
    var datas []#{struct_name}
    ets.Db.Select(&datas, "SELECT * FROM #{table_name} where user_id=?", playerId)
    for i := 0; i < len(datas); i++ {
      data := datas[i]
      model := &#{struct_name}Model{
          Ctx: ets.Ctx.(*player.Player),
          Data: &data,
      }
      ets.Load([]string{"models", "#{table_name}"}, data.Uuid, model)
    }
  })
}

    models[struct_name.downcase] = %Q{
package models

import (
	. "app/consts"
	"fmt"
	"gslib/player"
	. "goslib/base_model"
)
type #{struct_name}Model struct {
	Ctx *player.Player
	Data *#{struct_name}
}

func Find#{struct_name}(ctx *player.Player, uuid string) *#{struct_name}Model {
	return ctx.Store.Get([]string{"models", "#{table_name}"}, uuid).(*#{struct_name}Model)
}

func Create#{struct_name}(ctx *player.Player, data *#{struct_name}) *#{struct_name}Model {
	model := &#{struct_name}Model{
		Ctx: ctx,
		Data: data,
	}
	ctx.Store.Set([]string{"models", "#{table_name}"}, data.Uuid, model)
	return model
}

func (self *#{struct_name}Model) GetUuid() string {
	return self.Data.Uuid
}

func (self *#{struct_name}Model) GetTableName() string {
	return "#{table_name}"
}

func (self *#{struct_name}Model) Save() {
	self.Ctx.Store.UpdateStatus("#{table_name}", self.GetUuid(), STATUS_UPDATE)
}

func (self *#{struct_name}Model) Delete() {
	self.Ctx.Store.Del([]string{"models", "#{table_name}"}, self.GetUuid())
	self.Ctx.Store.UpdateStatus("#{table_name}", self.GetUuid(), STATUS_DELETE)
}

func (self *#{struct_name}Model) SqlForRec(status int8) string {
	data := self.Data
	switch status {
	case STATUS_DELETE:
		return fmt.Sprintf("DELETE FROM `#{table_name}` WHERE `uuid`='%s'", data.Uuid)
	case STATUS_CREATE:
        return fmt.Sprintf("INSERT INTO `#{table_name}` (#{field_names.join(", ")}) VALUES (#{field_types.join(", ")})", #{field_values.join(", ")})
	case STATUS_UPDATE:
        return fmt.Sprintf("UPDATE `#{table_name}` SET #{field_formatters.join(", ")} WHERE `uuid`='%s'", #{field_values.join(", ")}, data.Uuid)
	}
	return ""
} 
}
  end

  #################################################
  # Generate table structs
  #################################################
  structs_content << %Q{
    var StructToTableNameMap = map[string]string{
      #{struct_to_table_name}
    }
  }
  path = "src/app/consts/tables.go"
  File.open(path, "w") { |io| io.write structs_content }
  `go fmt #{path}`


  #################################################
  # Generate register_tables
  #################################################
  path = "src/app/register/tables/register_tables.go"
  File.open(path, "w") do |io| 
    io.write %Q{\
#{header}
package tables

import (
    . "app/consts"
    "github.com/go-gorp/gorp"
)

func RegisterTables(dbInstance *gorp.DbMap) {
#{register_content}
}}
  end
  `go fmt #{path}`


  #################################################
  # Generate data_loader
  #################################################
  path = "src/app/register/data_loader.go"
  File.open(path, "w") do |io|
    io.write %Q{\
#{header}
package register

import (
  . "app/consts"
  . "app/models"
	"goslib/memstore"
  "gslib/player"
)

func RegisterDataLoader() {\
#{data_loader.join("\n")}
}}
  end
  `go fmt #{path}`

  #################################################
  # Generate models
  #################################################
  models.each do |model_name, content|
    path = "src/app/models/#{model_name}_gen.go"
    File.open(path, "w") do |io|
      io.write %Q{\
      #{header}
      #{content}
  }
    end
    `go fmt #{path}`
  end
end

#!/usr/bin/env ruby

require "yaml"

source = "./src/config/protocol.yml"
target = "./src/api/protocol.go"

defines = YAML.load_file(source)

COMMON_TYPE = ['bool', 'byte', 'string', 
               'uint16', 'uint24', 'uint32', 'uint64', 
               'int16', 'int24', 'int32', 'int64',
               'float32', 'float64']
PROTOCOL_TYPE = defines.keys

package = "rawapi"
proto_dir = "./src/api/#{package}"
`mkdir -p #{proto_dir}`

#
# Generate api decoder
#
target = "#{proto_dir}/decoder.go"

def common_protocol(field_type, variable, code)
  if code == "write"
    "buffer.Write#{field_type.capitalize}(v.#{variable})"
  elsif code == "read"
    "data.#{variable} = buffer.Read#{field_type.capitalize}()"
  else
    assert(false, "Invalid code!")
  end
end

header = %Q{\
/*
 * Generated by tools/gen_protocol_raw
 */
}

encode_handlers = []
decode_handlers = []

defines.each do |protocol, define|
  encode_fields = []
  decode_fields = []
  define.each do |field, type|
    if COMMON_TYPE.include?(type)
      decode_fields << common_protocol(type, field, "read")
      encode_fields << common_protocol(type, field, "write")
    elsif PROTOCOL_TYPE.include?(type)
      decode_fields << %Q{data.#{field} = encode#{type}(buffer)}
      encode_fields << %Q{encode#{type}(buffer, v.#{field})}
    elsif type.index("array-") == 0
      sub_type = type.split('-')[1]
      if COMMON_TYPE.include?(sub_type)
        decode_fields << %Q{
    for i := 0; i < int(buffer.ReadUint16()); i++ {
        data.#{field} = append(data.#{field}, buffer.Read#{sub_type.capitalize}())
    }}
        encode_fields << %Q{
    buffer.WriteUint16(uint16(len(v.#{field})))
    for i := 0; i < len(v.#{field}); i++ {
        buffer.Write#{sub_type.capitalize}(v.#{field}[i])
    }}
      else
        decode_fields << %Q{
    for i := 0; i < int(buffer.ReadUint16()); i++ {
        data.#{field} = append(data.#{field}, decode#{sub_type}(buffer).(*api.#{sub_type}))
    }}
        encode_fields << %Q{
    buffer.WriteUint16(uint16(len(v.#{field})))
    for i := 0; i < len(v.#{field}); i++ {
        encode#{sub_type}(buffer, v.#{field}[i])
    }}
      end
    end
  end
  decode_handlers << %Q{
func decode#{protocol}(buffer *packet.Packet) interface{} {
    data := &api.#{protocol}{}
    #{decode_fields.join("\n    ")}
    return data
}}
  encode_handlers << %Q{
func encode#{protocol}(buffer *packet.Packet, value interface{}) {
    v := value.(*api.#{protocol})
    #{encode_fields.join("\n    ")}
}}
end

#
# Generate api decoder
#
File.open(target, "w") do |io|
  io.write %Q{\
#{header}
package #{package}

import (
        "api"
	"goslib/packet"
)

#{decode_handlers.join("\n")}

type DecodeHandler func(buffer *packet.Packet) interface{}

var decode_handlers = map[string]DecodeHandler{
    #{defines.keys.map{|protocol| "\"#{protocol}\": decode#{protocol}"}.join(",\n    ")}}

func Decode(decode_method string, buffer *packet.Packet) interface{} {
	if handler, ok := decode_handlers[decode_method]; ok {
		return handler(buffer)
	} else {
		return nil
	}
}
}
end
`gofmt -w #{target}`

#
# Generate api encoder
#
target = "#{proto_dir}/encoder.go"
File.open(target, "w") do |io|
  io.write %Q{\
#{header}
package #{package}

import (
        "api"
  	"goslib/packet"
)

#{encode_handlers.join("\n")}

type EncodeHandler func(buffer *packet.Packet, value interface{})
var encode_handlers = map[string]EncodeHandler{
    #{defines.keys.map{|protocol| "\"#{protocol}\": encode#{protocol}"}.join(",\n    ")}}

func Encode(encode_method string, v interface{}) *packet.Packet {
    protocol := api.NameToId[encode_method]
    buffer := packet.Writer()
    buffer.WriteUint16(protocol)
    encode_handlers[encode_method](buffer, v)
    return buffer
}
}
end
`gofmt -w #{target}`

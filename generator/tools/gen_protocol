#!/usr/bin/env ruby

require "yaml"

source = "./config/protocol.yml"
defines = YAML.load_file(source)

COMMON_TYPE = ['bool', 'byte', 'string', 
               'uint16', 'uint24', 'uint32', 'uint64', 
               'int16', 'int24', 'int32', 'int64',
               'float32', 'float64']

PROTOCOL_TYPE = []
defines.each do |k, p_defines|
  p_defines.each do |proto|
    PROTOCOL_TYPE << proto['name']
  end
end

header = %Q{\
/*
 * Generated by tools/gen_protocol
 */
}

#
# Generate protobuf files
#
package = "pt"
proto_dir = "../src/goslib/src/gen/api/#{package}"
`mkdir -p #{proto_dir}`
target = "#{proto_dir}/protocol.proto"

File.open(target, "w") do |io|
  io.write "//Generated by tools/gen_protocol_pb\n"
  io.write %Q(syntax = "proto3";\n)
  io.write "package pt;\n"
  defines.each do |type_key, protocol_defines|
    protocol_defines.each do |proto|
      key = proto['name']
      field_defines = proto['struct']
      fields = []
      idx = 0
      field_defines.each do |field, type|
        type == "float32" and type = "float"
        idx += 1
        if type.index("array-") == 0
          sub_type = type.split('-')[1]
          if PROTOCOL_TYPE.include?(sub_type)
            fields << "repeated #{sub_type} #{field} = #{idx};"
          else
            fields << "repeated #{sub_type} #{field} = #{idx};"
          end
        else
          fields << "#{type} #{field} = #{idx};"
        end
      end
      io.write %Q{
  message #{key} {
      #{fields.join("\n    ")}
  }
  }
    end
  end
end
`cd #{proto_dir} && protoc --go_out=. protocol.proto`

#
# Generate api map
#
target = "../src/goslib/src/gen/api/pt/api_map.go"
File.open(target, "w") do |io|
  consts = []

  pt_types = []
  id_to_type = []

  name_to_id = []
  id_to_name = []

  defines.keys.each_with_index do |type, idx|
    type_name = "PT_TYPE_#{type}"
    pt_types << %Q{#{type_name} = #{idx + 1}}

    defines[type].each do |proto|
      consts << %Q{PT_#{proto['name']} = "#{proto['name']}"}
      name_to_id << %Q{"#{proto['name']}": uint16(#{proto['id']})}
      id_to_name << %Q{uint16(#{proto['id']}): "#{proto['name']}"}
      id_to_type << %Q{uint16(#{proto['id']}): #{type_name}}
    end
  end

  io.write %Q{\
#{header}
package pt

var NameToId = map[string]uint16{
    #{name_to_id.join(",\n    ")},
}

var IdToName = map[uint16]string{
    #{id_to_name.join(",\n    ")},
}

var IdToType = map[uint16]int{
    #{id_to_type.join(",\n    ")},
}

const(
    #{consts.join("\n    ")}
)

const(
    #{pt_types.join("\n    ")}
)
}
end
`gofmt -w #{target}`

`ruby tools/gen_protocol_pb`
`ruby tools/gen_protocol_raw`
`ruby tools/gen_protocol_json`
